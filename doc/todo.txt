6/28/2023
* wow its been a long time lol and look i ts like 1 month 1 day exactly
* was looking at this again:
Goals for libs:
Renderer.Lib
Scene.Lib
 ^^ super useful 
 ^^ for like level generators for example
Core.lib
 ^^ to handle the dependencies

 do I still want to do this?!??
 is there really a point in Core.lib?
 Also what about dependencies
 like between renderer and scene 
 a renderer needs a scene.lib  
 maybe just figuring out  all the inputs and outputs of the renderer
 and all the inputs and outputs of the scene
 and all the inputs and o utputus of the core
 idk what im talking about rn tbh
 oneo of the important inputs of the renderer is the BVH
 the bvh is connected to the scene 
 it also depends on the type of rendnerer
 are you really gonna have multiple types like for computeu vs regular raytracer
 are you gonna learn regular vulkan raytracing
 my brain doesn'tn f eel charged rnWHERES MY COFFFEE IS IT STILL AL LTHE WAY OVER HTERE
  OOPS

  hmmmm
  maybe the BVH should be part of renderer instead of scene
  may sound counter intutive but... its only used for renderingand if you take
  a different path then it willb e gpu bound anyways

  DO YOU WANT TO CONTINUE WITH THIS?!?!? 
  yes/no what are the benefits etc//??? also how closoe are we
  once we get the raytracer up we can view t hings
  benefits are .... YES DO IT leggo
  sooo the api you want for the renderer is something like this...
  axiom::renderer::init()
  axiom::renderer::destroy()
  axiom::renderer::AddMaterial();
  also the more i think about grammar... the more i feel like it shoudlb e the opposite
  Axiom::Renderer::add_material()
  All nouns should be capitalized
  All actions should be lowercase
  why is everything so backwards
  Filenames should probably be caps too
  why is programming so fing backwards?!?!?
  why is it so hard to just make things like english
  like wtf is up with stoff like... iPhone or iNet or whatever
  just be normal????
  hmmmm
  maybe do a massive rewrite while its small and rewriteable

  Namespaces = caps... i mean just look at what its called NAMEspace... NAME = CAPITAL
  Structs/Classes = lowercase
  variables = caps

  axiom::log::Init()
  Axiom::Log::init();
  Axiom::Log::logger TheLogger;

  also screw people who say no comments i say comments everywhere!!!!!!
  I like encapsulation though but like... what about just like a private namespace?
  like let people have the ability to massively screw things up but give them teh freedom to see  anyways

5/27/2023
* just do vulkan first, then ecsify it later
* okay design your api:


axiom::renderer::init();
g_world.add<axiom::Cmp_Vulkan, axiom::Cmp_ComputeRaytracer>();

auto* cmp_crt = g_world.get_mut<Cmp_ComputeRaytracer>()
cmp_crt->do_stuff();


froku->add<Cmp_Render, Cmp_Primitive>

For the renderer there will be observers for:
    * OnAdd<Cmp_Render>
    * OnRemove<Cmp_Render>
    * OnAdd<Cmp_ComputeRaytracer>()
    * OnRemove<Cmp_ComputeRaytracer>()
    * OnAdd<Cmp_RenderFrame>() //framestart
    * OnRemvoe<Cmp_RenderFrame>() //frameend
System for update<Cmp_Render>

you can figure dat ish out later now question is... how do we get to axiom::renderer::init()?
renderer::init()
InitAllTheThings
Base::Init()

Question::Do you want to use Inheretance?
Just create a rendererobject
renderer::init()
new raytracer ???
no renderer::init sets all teh functions
when you add the raytracer component and the vulkcan component you create everything
remember::renderer is just a namespace with a bunch of functions
you can hide all functions in the base but its a lot of typing and also you'd need to pass in vulkan to every function


5/22/2023
* Vulkan boilerplate what to include?
* * more important.... shoudl everything be done in the same file?

 

5/17/2023
* Yesterday I came to realize that vulkan will always be messy
* * so just bare with it and muscle through
* * If your previous vulkan ish aint broke then dont fix it
* * There's no good way to make it super clean feeling
* However, the things you mentioned in 5/15 should be clean
* * you should encapsulate a lot of the disgustinig boilerplate
* * but keep public, your ability to manipulate those 6
* * and also debugging can be added to the list

 

* public: 
* 1. Shaders
* 2. Pipelines
* 3. FrameBuffers/Resize
* 4. Draw
* 5. debug
* 6. Buffers

 

* Question is: should there be a large public component that handles all vulkan
* or have like... just small component and a singleton that handles all the backend

 

* Better question is... is this slowing you down too much???
* is it okay to be slowed down? this is some foundational stuff...
* i mean it sucks... but once you get through this hurdle it'll be GOLDEN
* Okay so right now you have a vulkan device struct that has all the devices 
* * its a huge class that does many things
* * should i make it a component?
* * is that even possible?
* so yeah what you can do is... make the device a component,
* * and make those functions get the cmp
* but why? outside of the logical device...
* * maybe the queue, callback and commandpool... is anything else used that much?
* * only the logical device is used a lot, physical once, qfams a few
* yo real talk, there's legit no reason do to everything again i think a lot of yo ish is already clean
* and the messy ish.... can't help but be messy... its Vulkan just get yo ish up n runnin  usin volk
* question is though.... how to ECSify some of it, but i think that
* * the only way is to make a Cmp for vulkan and pass it in everywhere

 

* How about have:
* 1. vulkan-boilerplate-component
* * a. This handles everything thats like... only used once for initiization etc..
* 2. vulkan-common-component
* * a. This is for anything that might be used frequently across systems
* 3. compute-raytracer-component
* * a. This is making me question 2a tbh


5/16/2023
* Vulkan boilerplate = step 1
* * Initializing just like... the window to support vulkan
* * Setting up the debug stuff
* * Getting the Devices
* * * Seeing if it supports compute
* * * Seeing if it supports any other extensions
* * Setting Up the Swap/FrameBuffers
* * Setting Up the Queues
* * * Compute/Graphics/Transfer?

* Lets see if you can just create a device right now


5/15/2023
* Rendering Okay so yeah you want to start seeing stuff
* question is: do you want to throw in your renderer or build from bottom up
* So what do you need to do:
* 1. DataFlow to all the ShaderStructures
* 2. DataFlow for initial vulkan setup
* 3. Vulkan boilerplate/setup
* 4. Vulkan Start/Stop Render
* 5. Dataflow for Uniform Buffer updates
* 6. Vulkan Screen resizing 

5/11/2023
* I think the most important thing you can do right now is...
* * Get to a point where you can see things
* * anything
* * And then be able to move things
* * anything
* So right now you have a scene
* You need a BVH
* Then render
* You'll just have to use your own right now 
* Then try embree later


5/10/23 what do?
* Test out the transform for:
* * static_transform
* * Dynamic_Transform
* * * OnAdd/OnSet/OnUpdate
* 


https://github.com/SanderMertens/flecs/tree/master/examples/cpp

TODO:
* Transform System
* * For the static transform system, you want it to update only OnSet
* * For the dynamic transform system, you want it to update always
* * For both you want to use the Querybuilder and cascade system iter thing but...
* * * its like... you want both to be built the same so err thang laid out flat in memory but
* * * its like... you want the algo to happen per event... actually maybe... hmmm



* Physics System
* * Perfect place to test the transform system!




What do you want?
* Better Scene/Graph Management
* Better ECS
* Better BVH
* Better Multithreading
* I wanna know how to graphix
* shadows
* Better Game Scene Systeming
* Better Logging
* Better CMAKING/Build systeming
* Better SYS/CMP management
* Create a visual structure from the beginning
* Better Game/Frame Systeming
* Better UI/layering
* Better Organization
* Better Rendering system
* Serialization
* Prefabs

What are some From-The-Ground-Up archetectural changes?
* CMAKE - beginning
* SYS/CMP - beginning 
* Visual Structure - yeah we need dis
* Flecs fixes
* INPUT something that scales for anything (game and engine) easily
* LIBS so you can make tools easier
* * if lib then how do?
* * also it could help with like other ish
* Rendering - you kinda already have something tho?


What can flecs replace?
*Scene
*Serizliation
*node
*Frame
*prefab?

* Learning Path:


Goals for libs:
Renderer.Lib
Scene.Lib
 ^^ super useful 
 ^^ for like level generators for example
Core.lib
 ^^ to handle the dependencies
 