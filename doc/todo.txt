5/27/2023
* just do vulkan first, then ecsify it later
* okay design your api:


axiom::renderer::init();
g_world.add<axiom::Cmp_Vulkan, axiom::Cmp_ComputeRaytracer>();

auto* cmp_crt = g_world.get_mut<Cmp_ComputeRaytracer>()
cmp_crt->do_stuff();


froku->add<Cmp_Render, Cmp_Primitive>

For the renderer there will be observers for:
    * OnAdd<Cmp_Render>
    * OnRemove<Cmp_Render>
    * OnAdd<Cmp_ComputeRaytracer>()
    * OnRemove<Cmp_ComputeRaytracer>()
    * OnAdd<Cmp_RenderFrame>() //framestart
    * OnRemvoe<Cmp_RenderFrame>() //frameend
System for update<Cmp_Render>

you can figure dat ish out later now question is... how do we get to axiom::renderer::init()?
renderer::init()
InitAllTheThings
Base::Init()

Question::Do you want to use Inheretance?
Just create a rendererobject
renderer::init()
new raytracer ???
no renderer::init sets all teh functions
when you add the raytracer component and the vulkcan component you create everything
remember::renderer is just a namespace with a bunch of functions
you can hide all functions in the base but its a lot of typing and also you'd need to pass in vulkan to every function


5/22/2023
* Vulkan boilerplate what to include?
* * more important.... shoudl everything be done in the same file?

 

5/17/2023
* Yesterday I came to realize that vulkan will always be messy
* * so just bare with it and muscle through
* * If your previous vulkan ish aint broke then dont fix it
* * There's no good way to make it super clean feeling
* However, the things you mentioned in 5/15 should be clean
* * you should encapsulate a lot of the disgustinig boilerplate
* * but keep public, your ability to manipulate those 6
* * and also debugging can be added to the list

 

* public: 
* 1. Shaders
* 2. Pipelines
* 3. FrameBuffers/Resize
* 4. Draw
* 5. debug
* 6. Buffers

 

* Question is: should there be a large public component that handles all vulkan
* or have like... just small component and a singleton that handles all the backend

 

* Better question is... is this slowing you down too much???
* is it okay to be slowed down? this is some foundational stuff...
* i mean it sucks... but once you get through this hurdle it'll be GOLDEN
* Okay so right now you have a vulkan device struct that has all the devices 
* * its a huge class that does many things
* * should i make it a component?
* * is that even possible?
* so yeah what you can do is... make the device a component,
* * and make those functions get the cmp
* but why? outside of the logical device...
* * maybe the queue, callback and commandpool... is anything else used that much?
* * only the logical device is used a lot, physical once, qfams a few
* yo real talk, there's legit no reason do to everything again i think a lot of yo ish is already clean
* and the messy ish.... can't help but be messy... its Vulkan just get yo ish up n runnin  usin volk
* question is though.... how to ECSify some of it, but i think that
* * the only way is to make a Cmp for vulkan and pass it in everywhere

 

* How about have:
* 1. vulkan-boilerplate-component
* * a. This handles everything thats like... only used once for initiization etc..
* 2. vulkan-common-component
* * a. This is for anything that might be used frequently across systems
* 3. compute-raytracer-component
* * a. This is making me question 2a tbh


5/16/2023
* Vulkan boilerplate = step 1
* * Initializing just like... the window to support vulkan
* * Setting up the debug stuff
* * Getting the Devices
* * * Seeing if it supports compute
* * * Seeing if it supports any other extensions
* * Setting Up the Swap/FrameBuffers
* * Setting Up the Queues
* * * Compute/Graphics/Transfer?

* Lets see if you can just create a device right now


5/15/2023
* Rendering Okay so yeah you want to start seeing stuff
* question is: do you want to throw in your renderer or build from bottom up
* So what do you need to do:
* 1. DataFlow to all the ShaderStructures
* 2. DataFlow for initial vulkan setup
* 3. Vulkan boilerplate/setup
* 4. Vulkan Start/Stop Render
* 5. Dataflow for Uniform Buffer updates
* 6. Vulkan Screen resizing 

5/11/2023
* I think the most important thing you can do right now is...
* * Get to a point where you can see things
* * anything
* * And then be able to move things
* * anything
* So right now you have a scene
* You need a BVH
* Then render
* You'll just have to use your own right now 
* Then try embree later


5/10/23 what do?
* Test out the transform for:
* * static_transform
* * Dynamic_Transform
* * * OnAdd/OnSet/OnUpdate
* 


https://github.com/SanderMertens/flecs/tree/master/examples/cpp

TODO:
* Transform System
* * For the static transform system, you want it to update only OnSet
* * For the dynamic transform system, you want it to update always
* * For both you want to use the Querybuilder and cascade system iter thing but...
* * * its like... you want both to be built the same so err thang laid out flat in memory but
* * * its like... you want the algo to happen per event... actually maybe... hmmm



* Physics System
* * Perfect place to test the transform system!




What do you want?
* Better Scene/Graph Management
* Better ECS
* Better BVH
* Better Multithreading
* I wanna know how to graphix
* shadows
* Better Game Scene Systeming
* Better Logging
* Better CMAKING/Build systeming
* Better SYS/CMP management
* Create a visual structure from the beginning
* Better Game/Frame Systeming
* Better UI/layering
* Better Organization
* Better Rendering system
* Serialization
* Prefabs

What are some From-The-Ground-Up archetectural changes?
* CMAKE - beginning
* SYS/CMP - beginning 
* Visual Structure - yeah we need dis
* Flecs fixes
* INPUT something that scales for anything (game and engine) easily
* LIBS so you can make tools easier
* * if lib then how do?
* * also it could help with like other ish
* Rendering - you kinda already have something tho?


What can flecs replace?
*Scene
*Serizliation
*node
*Frame
*prefab?

* Learning Path:


Goals for libs:
Renderer.Lib
Scene.Lib
 ^^ super useful 
 ^^ for like level generators for example
Core.lib
 ^^ to handle the dependencies
 